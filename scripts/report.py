#!/bin/usr/python3
"""
    Capture Station Report Generation Script
    Author: Aniruddha Mysore
    Repository: https://github.com/animysore/cockpit
    Version: 4
    Requirements:
        - python 3
        - hdhomerun (hdhomerun_config command must be present)
        - smartmontools (smartctl command must be present and access granted)
        - pings.log file generated by pingcheck.sh
    Usage:
        - python3 report.py <pings.log file> <output file> 
"""
import re
import os
import sys
import json
import pprint
import subprocess
from glob import glob
from datetime import datetime, date, timedelta

"""
Check if command line arguements are passed
"""
if len(sys.argv) != 3:
    print('Usage: python3 report.py <pings.log file> <output file>')
    exit(1)

PING_FILE = sys.argv[1]
OUTPUT_FILE = sys.argv[2]

data = {
    'storage': {
        'disks' : [],
        'cards' : []
    },
    'security': {
        'failed_login': 0,
    },
    'network': {
        'log_start': 0,
        'log_end': 0,
        'downtimes': []
    },
    'hdhomerun_devices': [],
    'xmltv_entries': [],
    'captured_files': [],
    'errors': [],
    'generated_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
}

"""
    Utility function to run command and return stdout and stderr
"""
def exec(command):
    out = subprocess.Popen(command,stdout=subprocess.PIPE)
    stdout, stderr = out.communicate()
    stdout = stdout.decode('utf8')
    return stdout, stderr

"""
    Utility function to print and append error log 
"""
def log(message):
    data['errors'].append(message)
    print(message)

"""
    Use `df` command to get filesystem usage
    Filter disks and cards connected and save disk usage stats

    Using `smartctl` command to get usage
"""
stdout, stderr = exec(['which', 'smartctl'])
if stdout:
    smart = True
else:
    log("smartmontools not installed")
    smart = False

stdout, stderr = exec(['df'])

for i,row in enumerate(stdout.split('\n')):
    # skip first line
    if i==0: continue

    fields = row.split()

    # skip last line
    if len(fields) == 0: continue

    fsname = fields[0]
    type = None

    if fsname.startswith('/dev/sd'): type = 'disks'
    if fsname.startswith('/dev/root'): type = 'cards'

    if type:
        storagedata = {
            'name': fields[0],
            'available': fields[2],
            'used': fields[3],
        }
        if type == 'disks' and smart:
            smartout, stderr = exec(['sudo','smartctl','-a',fsname])
            # Device does not support smart test
            if ( 'Device does not support Self Test logging' in smartout or
                 'Unknown USB bridge' in smartout):
                 storagedata['smart_enabled'] = False
            else:
                storagedata['smart_enabled'] = True
                try:
                    selftest = re.search('# 1(.*)',smartout)
                    if selftest:
                        details = selftest.group(1).split('    ')
                        status = details[1]
                        lifetime = int(details[3])
                        storagedata['smart_report'] = {
                            'status': status,
                            'lifetime': lifetime
                        }
                except:
                    log('Error parsing SMART self test output')

        data['storage'][type].append(storagedata)

"""
    Read `/var/log/auth.log` to get failed login attempts
"""
try:
    open('/var/log/auth.log')
    stdout, stderr = exec(['grep', '-i',  'failed', '/var/log/auth.log'])
    data['security']['failed_login'] = len(stdout.split('\n'))
except:
    log('Permssion denied to access /var/log/auth.log')

"""
    Fetch list of hdhomerun devices connected.
    Use the hdhomerun_config command.
"""
stdout, stderr = exec(['which', 'hdhomerun_config'])


if stdout:
    hdout, stderr = exec(['hdhomerun_config', 'discover'])

    if (hdout!='no devices found'):
        for row in hdout.split('\n'):
            fields = row.split()

            #skip last line
            if len(fields) == 0: continue

            data['hdhomerun_devices'].append({
                'id': fields[2],
                'ip': fields[5]
            })
else:
    log('hdhomerun_config not found.')

"""
    Compute network downtimes using pings.log file.
    Empties the log file once computed.
"""
try:
    with open(PING_FILE, 'r+') as logfile:
        down = False
        last = None
        for i,line in enumerate(logfile.read().split('\n')):

            # skip last line
            if not line: continue

            # store starting timestamp of log
            if i==0: data['network']['log_start'] = line.split('\t')[0]

            # store line; used to catch the last non empty line of file
            last = line

            time, status = line.split('\t')
            if status == 'DOWN':
                if not down:
                    down = True
                    start = time
            else:
                if down:
                    down = False
                    end = time
                    data['network']['downtimes'].append({
                        'start': start,
                        'end': end
                    })
        
        # store ending timestamp of log
        data['network']['log_end'] = last.split('\t')[0]

        # if last non empty line is UP truncate file
        if last and last.split('\t')[1] == 'UP':
            logfile.truncate(0)

except FileNotFoundError:
    log('pings.log logfile not found')

except AttributeError:
    log('pings.log is empty')

"""
    Store capture details.
    /home/csa/xmltv/ required for xmltv entries
    /home/csa/tv/ required for list of files captured
"""
homedir = '/home/csa/'
xmldir = '{}xmltv/'.format(homedir)
tvdir = '{}tv/'.format(homedir)

if not os.path.isdir(homedir):
    log('{} not found. Cannot find capture directories.'.format(homedir))

else:
    # Checking capture details of last two days
    today = date.today().strftime('%Y/%Y-%m/%Y-%m-%d')
    yest = (date.today() - timedelta(1)).strftime('%Y/%Y-%m/%Y-%m-%d')

    # Number of xmltv entries 
    if not os.path.isdir(xmldir):
        log('{} not found. skipping xmltv entries'.format(xmldir))
    else:
        # use glob module to use wildcards - to avoid specifying language  
        todayfile = glob('{}{}-??.xmltv'.format(xmldir,today))
        yestfile = glob('{}{}-??.xmltv'.format(xmldir,yest))

        if yestfile:
            data['xmltv_entries'].append({
                'date': yest[-10:],
                'entries': len(open(yestfile[0]).read().splitlines()),
            })
        if todayfile:
            data['xmltv_entries'].append({
                'date': today[-10:], 
                'entries': len(open(todayfile[0]).read().splitlines()),
            })
    
    # Captured files
    if not os.path.isdir(tvdir):
        log('{} not found. skipping captured files'.format(tvdir))
    else:
        data['captured_files'].extend(glob('{}{}/*.mpg'.format(tvdir,yest)))
        data['captured_files'].extend(glob('{}{}/*.mpg'.format(tvdir,today)))

"""
    Log the generated data to output file specified
    Pretty print it to console.
"""
pp = pprint.PrettyPrinter()
pp.pprint(data)

with open(OUTPUT_FILE,'w') as file:
    json.dump(data,file)
    print('Successfully saved to report.json')
