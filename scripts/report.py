#!/bin/usr/python3
"""
    Capture Station Report Generation Script
    Author: Aniruddha Mysore
    Repository: https://github.com/animysore/cockpit
    Version: 2
    Requirements:
        - python 3
        - hdhomerun (hdhomerun_config command must be present)
        - smartmontools (smartctl command must be present and access granted)
        - pings.log file generated by pingcheck.sh
"""
import re
import sys
import json
import pprint
import subprocess
from datetime import datetime

data = {
    'storage': {
        'disks' : [],
        'cards' : []
    },
    'security': {
        'failed_login': 0,
    },
    'network': {
        'log_start': 0,
        'log_end': 0,
        'downtimes': []
    },
    'hdhomerun_devices': [],
    'errors': [],
    'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
}

"""
    Utility function to run command and return stdout and stderr
"""
def exec(command):
    out = subprocess.Popen(command,stdout=subprocess.PIPE)
    stdout, stderr = out.communicate()
    stdout = stdout.decode('utf8')
    return stdout, stderr

"""
    Use `df` command to get filesystem usage
    Filter disks and cards connected and save disk usage stats

    Using `smartctl` command to get usage
"""
stdout, stderr = exec(['which', 'smartctl'])
if stdout:
    smart = True
else:
    data['errors'].append("smartmontools not installed")
    smart = False

stdout, stderr = exec(['df'])

for i,row in enumerate(stdout.split('\n')):
    # skip first line
    if i==0: continue

    fields = row.split()

    # skip last line
    if len(fields) == 0: continue

    fsname = fields[0]
    type = None

    if fsname.startswith('/dev/sd'): type = 'disks'
    if fsname.startswith('/dev/mmc'): type = 'cards'

    if type:
        storagedata = {
            'name': fields[0],
            'available': fields[2],
            'used': fields[3],
        }
        if type == 'disks' and smart:
            smartout, stderr = exec(['sudo','smartctl','-a',fsname])
            # Device does not support smart test
            if ( 'Device does not support Self Test logging' in smartout or
                 'Unknown USB bridge' in smartout):
                 storagedata['smart_enabled'] = False
            else:
                storagedata['smart_enabled'] = True
                try:
                    selftest = re.search('# 1(.*)',smartout)
                    if selftest:
                        details = selftest.group(1).split('    ')
                        status = details[1]
                        lifetime = int(details[3])
                        storagedata['smart_report'] = {
                            'status': status,
                            'lifetime': lifetime
                        }
                except:
                    data['errors'].append('Error parsing SMART self test output')

        data['storage'][type].append(storagedata)

"""
    Read `/var/log/auth.log` to get failed login attempts
"""
stdout, stderr = exec(['grep', '-i',  'failed', '/var/log/auth.log'])


data['security']['failed_login'] = len(stdout.split('\n'))

"""
    Fetch list of hdhomerun devices connected.
    Use the hdhomerun_config command.
"""
stdout, stderr = exec(['which', 'hdhomerun_config'])


if stdout:
    hdout, stderr = exec(['hdhomerun_config', 'discover'])

    if (hdout!='no devices found'):
        for row in hdout.split('\n'):
            fields = row.split()

            #skip last line
            if len(fields) == 0: continue

            data['hdhomerun_devices'].append({
                'id': fields[2],
                'ip': fields[5]
            })
else:
    print('hdhomerun_config not found.\nSkipping HDHomeRun health check.')
    data['errors'].append('hdhomerun_config not found')

"""
    Compute network downtimes using pings.log file.
    Empties the log file once computed.
"""
try:
    with open('./pings.log', 'r+') as logfile:
        down = False
        last = None
        for i,line in enumerate(logfile.read().split('\n')):

            # skip last line
            if not line: continue

            # store starting timestamp of log
            if i==0: data['network']['log_start'] = line.split('\t')[0]

            # store line; used to catch the last non empty line of file
            last = line

            time, status = line.split('\t')
            if status == 'DOWN':
                if not down:
                    down = True
                    start = time
            else:
                if down:
                    down = False
                    end = time
                    data['network']['downtimes'].append({
                        'start': start,
                        'end': end
                    })
        
        # store ending timestamp of log
        data['network']['log_end'] = last.split('\t')[0]

        # if last non empty line is UP truncate file
        if last and last.split('\t')[1] == 'UP':
            logfile.truncate(0)

except FileNotFoundError:
    print('pings.log logfile not found')
    data['errors'].append('pings.log logfile not found')

"""
    Log the generated data to report.json
    Pretty print it to console.
"""
pp = pprint.PrettyPrinter()
pp.pprint(data)

with open('report.json','w') as file:
    json.dump(data,file)
    print('Successfully saved to report.json')
